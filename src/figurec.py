# -*- coding: utf-8 -*-
"""FigureC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ELfOQ8oOIL0cx9HyapmJO9XhvRlmJ-9M
"""

"""
Appendix Figure C (Option B): Excess concentration maps for alternative mobility values (lambda)

This script replicates the (Δ, σ) grid experiment while varying λ (mobility of illicit funds),
and plots the *excess* long-run concentration of illicit funds:

    Excess(Δ,σ;λ) = E_runs[  (1/(T-burn)) * sum_{t=burn}^{T-1} max_j share_{j,t}  ]  - 1/J

where share_{j,t} = M_{j,t} / M_total.

Baseline parameters are aligned with Figure 2:
J=12, T=2000, burn=500, grid=20x20 over Δ∈[0.005,0.08], σ∈[0,0.2], reps=40.
"""

from __future__ import annotations

import numpy as np
import matplotlib.pyplot as plt


def clip01(x: np.ndarray) -> np.ndarray:
    return np.clip(x, 0.0, 1.0)


def simulate_excess_max_share(
    *,
    rng: np.random.Generator,
    J: int,
    T: int,
    burn: int,
    theta: float,
    Dbar: float,
    Delta: float,
    sigma: float,
    lam: float,
    M_total: float,
) -> float:
    """
    Run one simulation and return the long-run average *excess* max share after burn-in.

    Dynamics (reduced-form + relocation):
      D_{t}   = theta * s_{t}
      Dhat_t  = D_t + eps_t,  eps_t ~ N(0, sigma^2)
      s_{t+1} = [ s_t + Delta*1{Dhat_t < Dbar} - Delta*1{Dhat_t > Dbar} ]_[0,1]
      M_{t+1} = M_total * exp(-lam * D_t) / sum_k exp(-lam * D_{k,t})
    """
    s = rng.uniform(0.0, 1.0, size=J)
    M = np.full(J, M_total / J)

    sum_max_share = 0.0
    denom = max(T - burn, 1)

    for t in range(T):
        D = theta * s

        # Record max share contemporaneously (after burn-in)
        if t >= burn:
            sum_max_share += (M.max() / M_total)

        # Noisy signal and adaptive update (t -> t+1)
        Dhat = D + rng.normal(0.0, sigma, size=J)
        s = clip01(s + Delta * (Dhat < Dbar) - Delta * (Dhat > Dbar))

        # Relocation (t -> t+1) based on contemporaneous detection D
        w = np.exp(-lam * D)
        M = M_total * w / w.sum()

    long_run_max_share = sum_max_share / denom
    excess = long_run_max_share - (1.0 / J)
    return float(excess)


def compute_surface(
    *,
    Delta_grid: np.ndarray,
    sigma_grid: np.ndarray,
    lam: float,
    reps: int,
    base_seed: int,
    J: int,
    T: int,
    burn: int,
    theta: float,
    Dbar: float,
    M_total: float,
) -> np.ndarray:
    H = np.zeros((len(sigma_grid), len(Delta_grid)), dtype=float)

    for si, sigma in enumerate(sigma_grid):
        for di, Delta in enumerate(Delta_grid):
            vals = np.empty(reps, dtype=float)

            # Deterministic per-(lam, sigma, Delta, rep) seeds for reproducibility
            for r in range(reps):
                seed = (
                    base_seed
                    + int(lam * 10_000)
                    + 1_000 * si
                    + 10 * di
                    + r
                )
                rng = np.random.default_rng(seed)
                vals[r] = simulate_excess_max_share(
                    rng=rng,
                    J=J,
                    T=T,
                    burn=burn,
                    theta=theta,
                    Dbar=Dbar,
                    Delta=float(Delta),
                    sigma=float(sigma),
                    lam=float(lam),
                    M_total=M_total,
                )

            H[si, di] = float(vals.mean())

    return H


def main() -> None:
    # --- Baseline settings (aligned with Figure 2) ---
    J = 12
    T = 2000
    burn = 500
    theta = 1.0
    Dbar = 0.5
    M_total = 1.0

    reps = 40
    base_seed = 12345

    # --- Grid (aligned with Figure 2) ---
    Delta_grid = np.linspace(0.005, 0.08, 20)
    sigma_grid = np.linspace(0.0, 0.20, 20)

    # --- Mobility cases ---
    lam_list = [2.0, 8.0]

    surfaces = []
    for lam in lam_list:
        H = compute_surface(
            Delta_grid=Delta_grid,
            sigma_grid=sigma_grid,
            lam=lam,
            reps=reps,
            base_seed=base_seed,
            J=J,
            T=T,
            burn=burn,
            theta=theta,
            Dbar=Dbar,
            M_total=M_total,
        )
        surfaces.append(H)

    # Common color scale for fair comparison (excess is >= 0 by construction)
    vmax = max(H.max() for H in surfaces)

    fig, axs = plt.subplots(1, 2, figsize=(14, 5), constrained_layout=True)

    for idx, (ax, lam, H) in enumerate(zip(axs, lam_list, surfaces)):
        im = ax.imshow(
            H,
            origin="lower",
            aspect="auto",
            cmap="Greys",
            vmin=0.0,
            vmax=vmax,
            extent=[Delta_grid.min(), Delta_grid.max(), sigma_grid.min(), sigma_grid.max()],
        )
        ax.set_title(f"Mobility (λ = {int(lam)})")
        ax.set_xlabel("Δ")
        if idx == 0:
            ax.set_ylabel("σ")
        else:
            ax.set_ylabel("")
            ax.set_yticklabels([])

    cbar = fig.colorbar(im, ax=axs, shrink=0.9)
    cbar.set_label("Long-run excess max illicit-fund share  (max share − 1/J)")

    out = "FigureC.png"
    plt.savefig(out, dpi=300, bbox_inches="tight")
    plt.show()
    print("Saved:", out)


if __name__ == "__main__":
    main()