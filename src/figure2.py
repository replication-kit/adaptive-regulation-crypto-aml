# -*- coding: utf-8 -*-
"""Figure2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14uRHXr1WeFrYoRSkPDtbgI-Zc9PsfUVH

# Figure 2 (Lock-in maps) — Reproducible Notebook

This notebook reproduces **Figure 2** by running the same code as `figure2_clean.py`.
Execute the cells top-to-bottom.
"""

# --- Code (from figure2_clean.py) ---
# -*- coding: utf-8 -*-
"""Generate Figure 2 (lock-in maps).

Reduced-form used for Figure 2
------------------------------
For Figure 2 we intentionally isolate the adaptive implementation + noisy
observation subsystem:

  D_{j,t}    = theta * s_{j,t}
  Dhat_{j,t} = D_{j,t} + eps_{j,t},   eps_{j,t} ~ N(0, sigma^2)
  s_{j,t+1}  = clip_{[0,1]}( s_{j,t}
                 + Delta * 1{Dhat_{j,t} < Dbar}
                 - Delta * 1{Dhat_{j,t} > Dbar} )

Figure-2 metrics follow Section 4:
  G_t = max_j D_{j,t} - min_j D_{j,t}
  G   = mean_{t>burn} G_t
Panel A: std dev of G across runs (population std, ddof=0).
Panel B: Pr(G > tau) across runs, with tau = alpha*theta.

Note: Other model parameters (e.g., lambda and total mass M) are not used in
this reduced-form mapping exercise; they are reported elsewhere for completeness.
"""

from __future__ import annotations

import numpy as np
import matplotlib.pyplot as plt


def clip01(x: np.ndarray) -> np.ndarray:
    """Project to [0,1]."""
    return np.minimum(1.0, np.maximum(0.0, x))


def simulate_once(
    *,
    J: int,
    T: int,
    burn: int,
    theta: float,
    Dbar: float,
    Delta: float,
    sigma: float,
    seed: int,
) -> float:
    """Run one simulation and return long-run average gap G."""
    rng = np.random.default_rng(seed)
    s = rng.uniform(0.0, 1.0, size=J)

    # Accumulate gaps after burn-in (faster than appending to a list)
    gap_sum = 0.0
    gap_count = 0

    for t in range(T):
        D = theta * s
        Dhat = D + rng.normal(0.0, sigma, size=J)
        s = clip01(s + Delta * (Dhat < Dbar) - Delta * (Dhat > Dbar))

        if t >= burn:
            gap_sum += (D.max() - D.min())
            gap_count += 1

    return gap_sum / gap_count


def figure2_data(
    deltas: np.ndarray,
    sigmas: np.ndarray,
    *,
    J: int = 12,
    T: int = 2000,
    burn: int = 500,
    theta: float = 1.0,
    Dbar: float = 0.5,
    runs: int = 40,
    alpha: float = 0.2,
    base_seed: int = 0,
) -> tuple[np.ndarray, np.ndarray, float]:
    """Compute Panel A/B maps and return (std_map, prob_map, tau)."""
    tau = alpha * theta

    std_map = np.zeros((len(sigmas), len(deltas)))
    prob_map = np.zeros_like(std_map)

    for i, sigma in enumerate(sigmas):
        for j, Delta in enumerate(deltas):
            vals = np.empty(runs)
            for r in range(runs):
                seed = base_seed + 10_000 * i + 100 * j + r
                vals[r] = simulate_once(
                    J=J,
                    T=T,
                    burn=burn,
                    theta=theta,
                    Dbar=Dbar,
                    Delta=Delta,
                    sigma=sigma,
                    seed=seed,
                )

            # Panel A: dispersion across runs
            std_map[i, j] = vals.std(ddof=0)  # population std (explicit)

            # Panel B: probability across runs
            prob_map[i, j] = np.mean(vals > tau)

    return std_map, prob_map, tau


def main() -> None:
    # Grid specification (Appendix A)
    deltas = np.linspace(0.005, 0.08, 20)
    sigmas = np.linspace(0.0, 0.20, 20)

    std_map, prob_map, tau = figure2_data(deltas, sigmas)

    fig, axes = plt.subplots(1, 2, figsize=(11, 4.5))

    # Panel A: Regime multiplicity
    im0 = axes[0].imshow(
        std_map,
        origin="lower",
        aspect="auto",
        cmap="gray_r",   # high = dark
        extent=[deltas.min(), deltas.max(), sigmas.min(), sigmas.max()],
    )
    axes[0].set_title("Panel A: Regime multiplicity")
    axes[0].set_xlabel("Adjustment step Δ")
    axes[0].set_ylabel("Observation noise σ")
    cbar0 = plt.colorbar(im0, ax=axes[0], fraction=0.046)
    cbar0.set_label("Lock-in index (dispersion)")

    # Panel B: Probability of severe lock-in (linear scale)
    im1 = axes[1].imshow(
        prob_map,
        origin="lower",
        aspect="auto",
        cmap="gray_r",   # high = dark
        vmin=0.0,
        vmax=1.0,
        extent=[deltas.min(), deltas.max(), sigmas.min(), sigmas.max()],
    )
    axes[1].set_title("Panel B: Probability of severe lock-in")
    axes[1].set_xlabel("Adjustment step Δ")
    axes[1].text(
        0.98,
        0.02,
        r"$\tau=\alpha\theta$",
        transform=axes[1].transAxes,
        ha="right",
        va="bottom",
        fontsize=10,
    )
    cbar1 = plt.colorbar(im1, ax=axes[1], fraction=0.046)
    cbar1.set_label(r"Pr(severe lock-in)")

    plt.tight_layout()
    plt.savefig("Figure2_lockin_bw.png", dpi=300)
    plt.show()

# Run to generate and save the figure
main()

# Confirm output file
import os
print('Saved:', os.path.abspath('Figure2_lockin_bw.png'))
print('Exists?', os.path.exists('Figure2_lockin_bw.png'))